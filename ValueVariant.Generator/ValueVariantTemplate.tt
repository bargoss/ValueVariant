<#@ template language="C#" linePragmas="false" #>
<#@ output extension=".cs" encoding="utf-8" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.ValueVariant" #>
<#@ include file="../Const.t4" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY ValueVariant.Generator. DO NOT CHANGE IT.
// </auto-generated>

using System;
using System.Runtime.InteropServices;
<# if (Options.HasFlag(ValueVariantGenerateOptions.MessagePackFormatter)) { #>

using MessagePack;
using MessagePack.Formatters;
<# } #>

#if NETCOREAPP2_1_OR_GREATER
using System.Diagnostics.CodeAnalysis;

#nullable enable
#endif

namespace <#= Namespace #>
{
    using V2 = global::System.ValueVariant;

    using T = global::<#= FullName #>;

<# for (var i = 1; i <= Count; ++i) { #>
    using T<#= i #> = global::<#= Types[i - 1] #>;
<# } #>

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
<# if (Options.HasFlag(ValueVariantGenerateOptions.MessagePackFormatter)) { #>
    [MessagePackFormatter(typeof(<#= TypeName #>.MessagePackFormatter))]
<# } #>
    readonly partial struct <#= TypeName #> : IEquatable<T>,
        <#= Join(1, Count, e => $"V2.Details.IValueVariantElement<T{e}>") #>
    {
        [StructLayout(LayoutKind.Explicit)]
        private readonly struct Union
        {
<# for (var i = 1; i <= Count; ++i ) { #>
            [FieldOffset(0)] internal readonly T<#= i #> Item<#= i #>;
<# } #>

<# for (var i = 1; i <= Count; ++i ) { #>
            internal Union(T<#= i #> value) : this() => this.Item<#= i #> = value;
<# } #>
        }

        private readonly Union UnionValue;

        public V2.TypeIndex<#= Count #> TypeIndex { get; }

        byte V2.Details.IValueVariant.TypeIndexByte => (byte)this.TypeIndex;

        private <#= TypeName #>(in Union value, V2.TypeIndex<#= Count #> index)
            => (this.UnionValue, this.TypeIndex) = (value, index);

<# for (var i = 1; i <= Count; ++i ) { #>
        public <#= TypeName #>(T<#= i #> value) : this(new Union(value), V2.TypeIndex<#= Count #>.Type<#= i #>) { }
<# } #>

<# for (var i = 1; i <= Count; ++i ) { #>
        public T<#= i #> Item<#= i #> => V2.Details.ValueVariant.GetValue<#= i #><Union, T<#= i #>>(this.UnionValue, (byte)this.TypeIndex);
<# } #>

<# for (var i = 1; i <= Count; ++i ) { #>
        public static implicit operator T(T<#= i #> value) => new T(value);
<# } #>

<# for (var i = 1; i <= Count; ++i ) { #>
        public static explicit operator T<#= i #>(in T value) => value.Item<#= i #>;
<# } #>

        public bool Equals(T other)
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.Equals(this, other);

#if NETCOREAPP2_1_OR_GREATER
        public override bool Equals([NotNullWhen(true)] object? obj)
#else
        public override bool Equals(object obj)
#endif
            => obj is T other && this.Equals(other);

        public static bool operator ==(in T lhs, in T rhs)
            => lhs.Equals(rhs);

        public static bool operator !=(in T lhs, in T rhs)
            => !lhs.Equals(rhs);

        public override int GetHashCode()
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.GetHashCode(this);

        public override string ToString()
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.ToString(this);

        public interface IActionVisitor : <#= Join(1, Count, e => $"V2.IValueVariantActionVisitor<T{e}>") #> { }

        public interface IActionVisitor<in TA1> : <#= Join(1, Count, e => $"V2.IValueVariantActionVisitor<T{e}, TA1>") #> { }

        public interface IFuncVisitor<out TR> : <#= Join(1, Count, e => $"V2.IValueVariantFuncVisitor<T{e}, TR>") #> { }

        public interface IFuncVisitor<in TA1, out TR> : <#= Join(1, Count, e => $"V2.IValueVariantFuncVisitor<T{e}, TA1, TR>") #> { }

        public void Accept(IActionVisitor visitor)
            => this.AcceptActionVisitor(visitor);

        public void Accept<TA1>(IActionVisitor<TA1> visitor, TA1 arg1)
            => this.AcceptActionVisitor(visitor, arg1);

        public TR Accept<TR>(IFuncVisitor<TR> visitor)
        {
            this.AcceptFuncVisitor(visitor, out TR result);
            return result;
        }

        public TR Accept<TA1, TR>(IFuncVisitor<TA1, TR> visitor, TA1 arg1)
        {
            this.AcceptFuncVisitor(visitor, arg1, out TR result);
            return result;
        }

        public void Accept(V2.IValueVariantGenericActionVisitor visitor)
            => this.AcceptGenericActionVisitor(visitor);

        public void Accept<TA1>(V2.IValueVariantGenericActionVisitor<TA1> visitor, TA1 arg1)
            => this.AcceptGenericActionVisitor(visitor, arg1);

        public TR Accept<TA1, TR>(V2.IValueVariantGenericFuncVisitor<TA1, TR> visitor, TA1 arg1)
        {
            this.AcceptGenericFuncVisitor(visitor, arg1, out TR result);
            return result;
        }

        public TR Accept<TR>(V2.IValueVariantGenericFuncVisitor<TR> visitor)
        {
            this.AcceptGenericFuncVisitor(visitor, out TR result);
            return result;
        }

        public void AcceptActionVisitor<TV>(in TV visitor)
            where TV : <#= Join(1, Count, e => $"V2.IValueVariantActionVisitor<T{e}>") #>
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptActionVisitor(this, visitor);

        public void AcceptActionVisitor<TV, TA1>(in TV visitor, TA1 arg1)
            where TV : <#= Join(1, Count, e => $"V2.IValueVariantActionVisitor<T{e}, TA1>") #>
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptActionVisitor(this, visitor, arg1);

        public void AcceptFuncVisitor<TV, TR>(in TV visitor, out TR result)
            where TV : <#= Join(1, Count, e => $"V2.IValueVariantFuncVisitor<T{e}, TR>") #>
            => result = V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptFuncVisitor<T, TV, TR>(this, visitor);

        public void AcceptFuncVisitor<TV, TA1, TR>(in TV visitor, TA1 arg1, out TR result)
            where TV : <#= Join(1, Count, e => $"V2.IValueVariantFuncVisitor<T{e}, TA1, TR>") #>
            => result = V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptFuncVisitor<T, TV, TA1, TR>(this, visitor, arg1);

        public void AcceptGenericActionVisitor<TV>(in TV visitor)
            where TV : V2.IValueVariantGenericActionVisitor
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptGenericActionVisitor(this, visitor);

        public void AcceptGenericActionVisitor<TV, TA1>(in TV visitor, TA1 arg1)
            where TV : V2.IValueVariantGenericActionVisitor<TA1>
            => V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptGenericActionVisitor(this, visitor, arg1);

        public void AcceptGenericFuncVisitor<TV, TR>(in TV visitor, out TR result)
            where TV : V2.IValueVariantGenericFuncVisitor<TR>
            => result = V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptGenericFuncVisitor<T, TV, TR>(this, visitor);

        public void AcceptGenericFuncVisitor<TV, TA1, TR>(in TV visitor, TA1 arg1, out TR result)
            where TV : V2.IValueVariantGenericFuncVisitor<TA1, TR>
            => result = V2.Details.ValueVariant<<#= Join(1, Count, e => $"T{e}") #>>.AcceptGenericFuncVisitor<T, TV, TA1, TR>(this, visitor, arg1);

        public struct DefaultConverter : IFuncVisitor<T>
        {
<# for (var i = 1; i <= Count; ++i ) { #>
            public T Visit(in T<#= i #> value) => value;
<# } #>
        }
<# if (Options.HasFlag(ValueVariantGenerateOptions.MessagePackFormatter)) { #>

        private sealed class MessagePackFormatter : IMessagePackFormatter<T>
        {
            public void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options)
            {
                options.Resolver.GetFormatterWithVerify<V2.TypeIndex<#= Count #>>().Serialize(ref writer, value.TypeIndex, options);
                switch (value.TypeIndex) {
<#   for (var i = 1; i <= Count; ++i) { #>
                    case V2.TypeIndex<#= Count #>.Type<#= i #>: options.Resolver.GetFormatterWithVerify<T<#= i #>>().Serialize(ref writer, value.Item<#= i #>, options); break;
<#   } #>
                    default: throw new InvalidOperationException();
                }
            }

            public T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
            {
                var index = options.Resolver.GetFormatterWithVerify<V2.TypeIndex<#= Count #>>().Deserialize(ref reader, options);
                return index switch {
<#   for (var i = 1; i <= Count; ++i) { #>
                    V2.TypeIndex<#= Count #>.Type<#= i #> => new T(options.Resolver.GetFormatterWithVerify<T<#= i #>>().Deserialize(ref reader, options)),
<#   } #>
                    _ => throw new InvalidOperationException()
                };
            }
        }
<# } #>
    }
}
